"""
These are the definitions of two classes: Side and Swap.  Side is a set of
cashflows, Swap defines an Interest Rate Swap.

Author: Phineas Campbell
Date:   8th October 2017
"""
# pylint linelength = 100

from phin64 import ISODate
import phin64

# The date generator uses an enum to define the dates to add.
SUPPORTED_TENORS = {'ON':(phin64.D, 1), '1W':(phin64.D, 7), '1M':(phin64.M, 1),
                    '2M':(phin64.M, 2), '3M':(phin64.M, 3), '6M':(phin64.M, 6),
                    '12M':(phin64.M, 12), '1Y':(phin64.Y, 1)}
# The swap class behaves differently if a swap with a given maturity is passed these are the valid
# maturities
VALID_MATURITIES = set([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])


class Side(ISODate):
    """
    A sequence of cashflows as a dictionary.  The keys are dates in IDO YYYYMMDD format and the
    values are a money amount to paid or received at that date.  The dates can be built up by
    adding a number of days to a start date of subtracting a number of days from an end date
    """
    def __init__(self, value_date, maturity, rate, pay, fixed, curve):
        """
        Build the set of cashflows either with rate as a a fixed rate or float cash with the
        float rate generated by the curve object
        """
        self._pay = pay
        self._fixed = fixed
        self._cashflows = dict()
        self._curve = curve
        self._value_date = value_date
        self._maturity = maturity
        self._rate = rate
        self._tenor_date = SUPPORTED_TENORS['6M']
        current_rate = 0.0053913  #TODO remove magic number
        old_date = value_date
        if pay:
            self._polarity = -1
        else:
            self._polarity = 1
        # There are two cases: a new swap and an existing swap.  With a new swap
        # the cashflows can be built up from the trade date. If the maturity
        # is in years then it is a new swap
        if self._maturity in VALID_MATURITIES:
            date_generator = ISODate(self._value_date)
            # Split the fixed and float side
            if self._fixed is True:
                for i in range(2*maturity+1):
                    pay_date = date_generator.DateIncrement(self._tenor_date[0], self._tenor_date[1]*i, False)
                    # There is no flow on value date
                    if pay_date == value_date:
                        self._cashflows[pay_date] = 0
                    else:
                        self._cashflows[pay_date] = self._polarity*self._rate*date_generator.YearFrac(old_date, pay_date)
                        old_date = pay_date
            # It must be a float side
            else:
                for i in range(2*maturity+1):
                    pay_date = date_generator.DateIncrement(self._tenor_date[0], self._tenor_date[1]*i, False)
                    # There is no flow on value date
                    if pay_date == value_date:
                        self._cashflows[pay_date] = 0
                    else:
                        float_rate = self._curve.AnnualRateFromISODate(old_date, pay_date)
                        self._cashflows[pay_date] = self._polarity*float_rate*date_generator.YearFrac(old_date, pay_date)
                        old_date = pay_date
        # It must be an existing swap in which case the cashflows are built down from maturity
        else:
            date_generator = ISODate(self._maturity)
            # Build the cashflows down while the date is greater than the value date
            pay_date = self._maturity
            self._cashflows[pay_date] = 0.0
            date_adj = -1
            while pay_date >= self._value_date:
                pay_date = date_generator.DateIncrement(2, date_adj*6, False)  # TODO replace magic number
                self._cashflows[pay_date] = 0.0
                date_adj -= 1
            # Now do the cashflows
            sorted_keys = sorted(self._cashflows.keys())
            # If it is fixed
            if fixed:
                for pay_date in sorted_keys:
                    # There are no payments before the value date
                    if pay_date <= value_date:
                        old_date = pay_date
                    else:
                        self._cashflows[pay_date] = self._polarity*rate*date_generator.YearFrac(old_date, pay_date)
                    old_date = pay_date
            # Then it must be float
            else:
                for j, pay_date in enumerate(sorted_keys):
                    # There are no payments before the value date
                    if pay_date <= value_date:
                        self._cashflows[pay_date] = 0.0
                        old_date = pay_date  # TODO fix additional
                    else:
                        # If this is the first payment then use the existing rate
                        if j == 1:
                            self._cashflows[pay_date] = self._polarity*current_rate*date_generator.YearFrac(old_date, pay_date)
                        else:
                            self._cashflows[pay_date] = self._polarity*self._curve.AnnualRateFromISODate(old_date, pay_date)*date_generator.YearFrac(old_date, pay_date)
                        old_date = pay_date

    def pv(self):
        """
        Return the PV for the cash flows using the curve defined in self._curve
        """
        pv_pay = 0
        for date, cashflow in self._cashflows.items():
            pv_pay += cashflow*self._curve.GetDFFromISODate(date)
        return pv_pay


class Swap(Side):
    """
    A swap consiting of two sides: a pay side and a receive side. The side can
    be either fixed or float.
    """
    def __init__(self, value_date, trade, curve):
        """
        Create the swap by defined in trade
        """
        self._id = trade['Id']
        self._instrument = trade['Instrument']
        self._notional = trade['Notional']
        self._currency = trade['Currency']
        self._maturity = trade['Maturity']
        self._rate = trade['Rate']
        self._receive = trade['Receive']
        self._curve = curve
        if trade['Pay'] == 'Fixed':
            self._pay_fixed = True
            self._pay_float = False
        else:
            self._pay_fixed = False
            self._pay_float = True
        # Pay side flows
        self._pay_side_flows = Side(value_date, self._maturity, self._rate, True, False, self._curve)
        # Receive Side Flows
        self._receive_side_flows = Side(value_date, self._maturity, self._rate, False, True, self._curve)

    def pay_side_pv(self):
        """
        Return the PV cashflows for the pay side of the swap
        """
        return self._notional * self._pay_side_flows.pv()

    def receive_side_pv(self):
        """
        Return the PV of the cashflows for the receive side
        """
        return self._notional * self._receive_side_flows.pv()

    def pv(self):
        """
        Return the PV of the cashflows by summing the receive a pay side flows
        """
        return self._notional * (self._receive_side_flows.pv() + self._pay_side_flows.pv())
